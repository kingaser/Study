## SOLID

### 객체 지향 설계 5원칙
모든 코드에서 LSP를 지키기에는 어렵습니다. 리스코프 치환 원칙에 따르면 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대신하더라도 의도에 맞게 작동되어야 된다고 했습니다.
SOLID 원칙이란 객체지향 설계에서 지켜줘야 할 5개의 소프트웨어 개발원칙 SRP, OCP, LSP, ISP, DIP 를 말합니다.
- SRP(Single Responsibility Principle) : 단일 책임 원칙
- OCP(Open Closed Principle) : 개방 폐쇄 원칙
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation Principle) : 인터페이스 분리의 원칙
- DIP(Dependency Inversion Principle) : 의존성 역전의 원칙

SOLID 설계 원칙은 앞으로 배우게 될 여러 디자인 패턴드링 SOLID 설계 원칙에 입각해서 만들어진 것이기 때문에, 표준화 작업에서부터
아키텍처 설계에 이르기까지 다양하게 적용됩니다.
이에 근간이 되는 SOLID 원칙에 대해 탄탄하게 알아볼 필요가 있습니다.

본래 좋은 소프트웨어란 변화에 대응을 잘 하는 것을 말합니다.
좋은 설계란 시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조를 말합니다.
시스템에 예상하지 못한 변경사항이 발생하더라도, 유연하게 대처하고 이후에 확장성이 있는 시스템 구조를 만들 수 있습니다.

SOLID 객체지향 원칙을 적용하면 코드를 확장하고 유지 보수 관리하기가 더 쉬워지며, 불필요한 복잡성을 제거해
리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있습니다.

### SRP - 단일 책임 원칙
- 클래스(객체)는 단 하나의 책임만 가져야 한다는 원칙
- 책임은 하나의 기능 담당이라는 의미로 보면 됨
- 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러개 설게하라는 원칙
- 하나의 클래스에 기능이 여러개 있다면 기능 변경이 일어났을 때 수정해야 할 코드가 많아짐
- SRP 원칙을 따름으로써 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용을 극복할 수 있음
- 최종적으로 단일 책임 원칙의 목적은 프로그램의 유지보수성을 높이기 위한 설계 기법
- 책임의 범위는 딱 정해져있는 것이 아니고, 어떤 프로그램을 개발하느냐에 따라 개발자마다 생각 기준이 다를 수 있음
---
적용 방법
- 리팩토링에서 소개하는 대부분의 위험상황에 대한 해결방법은 직/간접적으로 SRP 원리와 관련이 있으며, 이는 항상 코드를
최상으로 유지한다는 리팩토링의 근본정신도 항상 객체들의 책임을 최상의 상태로 분배한다는 것에서 비롯되기 때문입니다.

- 여러 원인에 의한 변경을 통해 혼재된 각 책임을 각각의 개별 클래스로 분할하여 클래스 당 하나의 책임만을 맡도록 하는 것입니다.
- 여기서 관건은 책임만 분리하는 것이 아니라 분리된 두 클래스간의 관계의 복잡도를 줄이도록 설계하는 것입니다.
- 만약 각각의 클래스들이 유사하고 비슷한 책임을 중복해서 갖고 있다면 SuperClass를 사용할 수 있습니다.
- 이것은 각각의 클래스들의 공유되는 요소를 부모 클래스로 정의하여 부모 클래스에 위임하는 기법입니다.
- 따라서 각각의 유사한 책임들은 부모에게 명백히 위임하고 다른 책임들은 각자에게 정의할 수 있습니다.

- 산발적으로 여러 곳에 분포된 책임들을 한 곳에 모으면서 설계를 깨끗하게 합니다.
- 응집성을 높이는 작업입니다.

### OCP - 개방 폐쇄 원칙
- 클래스는 "확장에 열려있어야 하고, 수정에는 닫혀있어야 한다"라는 의미를 갖고 있습니다.
- 기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서, 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성하는 설계 기법입니다.
  - 확장에 열려있다 : 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있음
  - 변경에 닫혀있다 : 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함
- 추상화 사용을 통한 관계 구축 권장을 의미하는 것입니다.
- 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- OCP를 가능케 하는 중요 메커니즘은 추상화와 다형성입니다.
- OCP는 객체지향의 장점을 극대화하는 아주 중요한 원리라 할 수 있습니다.

---
적용 방법
- 변경(확장)될 것과 변하지 않을 것을 엄격히 구분
- 이 두 모듈이 만나는 지점에 인터페이스를 정의
- 구현에 의존하기보다 정의한 인터페이스에 의존하도록 코드를 작성

### LSP - 리스코프 치환 원칙
- 서브 타입은 언제나 기반(부모) 타입으로 교체할 수 있어야 한다는 원칙입니다.
- LSP는 다형성 원리를 이용하기 위한 원칙 개념으로 보면 됩니다.
- LSP란, 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면,
업 캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 하는 것을 의미합니다.
- 기본적으로 LSP 원칙은 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야합니다.
- 상속은 구현상속(extends)이든 인터페이스 상속(implements)이든 궁극적으로 다형성을 통한 확장성 획득을 목표로 합니다. LSP 역시 서브 클래스가 확장에 대한 인터페이스를 준수해야 함을 의미합니다.
- 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문입니다.

---
적용 방법
- 만약 두 개체가 똑같은 일을 한다면 둘을 하나의 클래스로 표현하고 이들을 구분할 수 있는 필드를 둠
- 똑같은 연산을 제공하지만 이들을 약간씩 다르게 한다면 공통의 인터페이스를 만들고 둘이 이를 구현(인터페이스 상속)
- 공통된 연산이 없다면 완전 별개인 2개의 클래스를 만듦
- 만약 두 개체가 하는 일에 추갖거으로 무언가를 더 한다면 구현 상속을 사용

### ISP - 인터페이스 분리의 원칙
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리입니다.
- 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 합니다.
- "하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다"라고 정의할 수 도 있습니다.
- SRP 원칙이 클래스의 단일 책임을 강조한다면, ISP는 인터페이스의 단일 책임을 강조하는 것으로 보면 됩니다.
- SRP 원칙의 목표는 클래스 분리를 통하여 이루어진다면, ISP 원칙은 인터페이스 분리를 통해 설계하는 원칙입니다.
- ISP 원칙은 인터페이스를 사요하는 클라이언트를 기준으로 분리함으로써, 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공하는 것이 목표입니다.
- ISP 원칙의 주의해야 할 점은 한번 인터페이스를 분리하여 구성해놓고 나중에 무언가 수정사항이 생겨서 또 인터페이스들을 분리하는 행위를 가하지 말아야 합니다.(인터페이스는 한번 구성하였으면 왠만해선 변하면 안되는 정책 개념)

---
적용방법
- 클래스 인터페이스를 통한 분리
  - 클래스의 상속을 이용하여 인터페이스를 나눌 수 있습니다.
  - 이와 같은 구조는 클라이언트에게 변화를 주지 않을 뿐 아니라 인터페이스를 분리하는 효과를 갖습니다.
  - 하지만 거의 모든 객체지향 언어에서는 상속을 이용한 확장은 상속받는 클래스의 성격을 디자인 시점에 규정해 버립니다.
  - 따라서 인터페이스를 상속받는 순간 인터페이스에 예속되어 제공하는 서비스의 성격이 제한됩니다.
 
- 객체 인터페이스를 통한 분리
  - 위임(Delegation)을 이용하여 인터페이스를 나눌 수 있습니다.
  - 위임이란, 특정 일의 다른 클래스나 메서드에 맡기는 것입니다.
  - 만약 다른 클래스의 기능을 사용해야 하지만 그 기능을 변경하고 싶지 않다면, 상속 대신 위임을 사용합니다.
 
### DIP - 의존성 역전의 원칙
- 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전입니다.
- 실제 사용 관게는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대하 느슨하게 만드는 원칙입니다.
- 구현 클래스에 의존하지 말고, 인터페이스(추상)에 의존하라는 뜻입니다.
- 의존 관게를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는, 변화하기 어려운 것 거의 변화가 없는 것에 의존하라는 것입니다.
- DIP의 키워드는 IoC, 훅 메서드, 확장성입니다.
- 이 세가지 요소가 조합되어 복잡한 컴포넌트들의 관계를 단순화하고 컴포넌트 간의 커뮤니케이션을 효율적이게 합니다.
- DIP는 복잡하고 지난한 컴포넌트간의 커뮤니케이션 관계를 단순화하기 위한 원칙입니다.
- 실 세계에서도 헐리우드 원칙에서와 같이 귀찮도록 자주 질문과 요청을 하는 동료에게도 써먹어 볼만한 원칙입니다.

* 훅 메서드 : 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메서드
서브클래스에서는 추상 메서드를 구현하거나, 훅 메서드를 오버라이드하는 방법을 이용해 기능의 일부를 확장
---
적용방법
- Layering
  - Grady Booch는 "...all well structured object-oriented architectures have clearly-defined layers, with each layer providing some coherent set of services thought a well-defined and controlled interface"라고 하였습니다.
  - 즉, 잘 구조화된 객체지향 아키텍처들은 레리어마다 잘 정의되고 통제되는 인터페이스를 통한 긴밀한 서비스들의 집합을 제공하는 레이어들로 구성되어 있습니다.
  - 이것은 단순히 레이어를 통한 구조화만을 뜻하는 것이 아니라 Transitive Dependency가 발생했을 때 상위 레벨의 레이어가 하위 레벨의 레이어를 바로 의존하게 하는 것이 아니라 이 둘 사이에 존재한는
추상레벨을 통해 의존해야 할 것을 말하고 있습니다.
  - 이를 통해서 상위 레벨의 모듈은 하위 레벨의 모듈로의 의존성에서 벗어나 그 자체로 재사용 되고 확장성도 보장 받을 수 있습니다.
