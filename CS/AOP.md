## AOP(Aspect-Oriented Programming)
- 관점 지향 프로그래밍이라고도 불립니다.
- 소프트웨어 개발에서 모듈성을 향상시키기 위한 프로그래밍 패러다임입니다.
- 코드를 기능별로 나누는 전통적인 객체지향 프로그래밍(OOP)을 보완하거나 확장하는 목적으로 사용합니다.
- 주로 큰 규모의 애플리케이션에서 발생하는 공통 관심사(Cross-Cutting Concerns)를 분리하여 모듈화하는 방식 제공합니다.
- 공통 관심사
  - 어플리케이션 내에서 여러 모듈이나 기능에서 공통으로 필요한 로깅, 보안, 트랜잭션 관리와 같은 부분
  - 이러한 관심사는 여러 부분에 중복되어 등장하면서 코드의 복잡성을 증가시키고 유지보수를 어렵게 만들 수 있음

### AOP 적용 방법
1. 바이트 코드 조작
  - 프록시패턴과는 다르게 바이트 코드 조작 방식은 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 택합니다.
  - AspectJ는 프록시와는 다르게 좀 더 직접적인 방법으로 부가기능을 제공하는데, 컴파일된 Target의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채
바이트 코드를 조작하는 방법을 사용합니다. 그렇기 때문에 .java파일과 .class 파일을 비교해보면 내용이 달리진걸 확인할 수 있습니다.

  - 바이트 코드 조작을 사용하는 이유
    - 스프링과 같은 DI 컨테이너의 도움을 받지 않아도 AOP를 적용할 수 있습니다.
그렇기에 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해집니다.
    - 프록시 방식보다 강력하고 유연한 AOP가 가능합니다.
프록시를 AOP의 핵심 메커니즘으로 사용할 경우 부가기능(공통 모듈)을 부여할 대상은 클라이언트가 호출할 때 사용하는 메서드로 제한됩니다.
하지만, 바이트 코드 조작 방식을 사용하면, 오브젝트의 생성, 필드 값 조회 및 조작, 스태틱 초기화 등 다양한 작업에 부가기능을 부여할 수 있습니다.
이처럼 프록시를 사용한 AOP에서는 불가능한 부분에서까지 부가기능 부여가 가능하기 때문에 강력하고 유연합니다.

2. 프록시 패턴(스프링 AOP가 사용하는 방법)
  - 공통 모듈을 프록시로 만들어서 DI로 연결된 Bean 사이에 적용해 Target의 메서드 호출 과정에 참여해 부가기능을 제공합니다.
그렇기에 JDK와 SPring Container외에 특별한 기술 및 환경을 요구하지 않습니다.
  - Advice가 구현하는 MethodInterceptor 인터페이스는 다이나믹 프록시의 InvocationHandler와 마찬가지로 프록시부터 메서드 요청정보를 전달받아
타깃 오브젝트의 메서드를 호출하는데, 이렇게 메서드를 호출하는 전/후로 부가기능을 제공할 수 있습니다.
  - 이런식으로 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메서드에 다이나믹하게 적용해주기 위해 가장 중요한 역할을 맡고있는게
프록시고, 스프링 AOP는 프록시 방식의 AOP라 할 수 있습니다.

- 적용 방식
  - 컴파일 시점 적용
    - 컴파일 시점 적용 방식은 AspectJ 컴파일러가 일반 .java 파일을 컴파일할 때 부가기능을 넣어서 .class 파일로 컴파일해주는 것을 의미합니다.
    - 이 동작을 에스팩트와 실제 코드를 연결하는 위빙(weaving)이라고 부릅니다.
  - 클래스 로딩 시점 적용
    - JVM내 클래스로더에 .class 파일을 올리는 시점에 바이트 코드를 조작해 부가기능 로직을 추가하는 방식입니다.
  - 런타임 시점 적용
    - 컴파일, 클래스 로딩, main() 메서드의 실행 이후에 자바가 제공하는 범위내에 부가기능을 적용하는 방식입니다.
    - 이미 런타임 중이라 코드를 조작하기 어려워 스프링, 컨테이너, DI, 빈 등 여러 개념과 기능을 총동원하여 프록시를 통해 부가기능을 적용하는 방식입니다.
    - 프록시는 메서드 실행 시점에서만 다음 Target을 호출할 수 있기 때문에, 런타임 시점에 부가기능을 적용하는 방식은 메서드의 실행 지점으로 제한됩니다.

### Aspect(관점)
- 관심사의 모듈화된 단위
- 로깅이나 트랜잭션 관리와 같은 공통 관심사를 Aspect로 나타낼 수 있음
- Aspect는 특정한 기능을 수행하며, 어플리케이션의 여러 부분에 적용

### Advice(조언)
- Aspect가 수행할 작업을 정의하는 부분
- 언제, 어디서, 어떻게 Aspect를 적용할지를 결정
- 주요한 Advice 유형으로는 "before"(메서드 호출 전), "after"(메서드 호출 후), "around"(메서드 호출 전후)

### Join Point(결합 지점)
- Join Point는 어플리케이션 코드 내에서 Aspect가 적용될 수 있는 특정한 지점을 나타냄
- 메서드 호출, 필드 접근 등이 Join Point에 해당

### Pointcut(포인트컷)
- Join Point중에서 실제로 Advice가 적용될 지점들을 선택하는 방식을 정의
- 모든 서비스 계층의 메서드 호출 시점에 로깅을 추가하고 싶다면, 해당 메서드들을 대상으로 하는 Pointcut을 작성

### Weaving(위빙)
- Aspect를 어플리케이션 코드에 실제로 삽입하는 과정
- Aspect의 Advice를 해당하는 Join Point에 적용하여 어플리케이션 코드에 Aspect의 동작을 끼워 넣는 프로세스

---
- AOP는 코드의 재사용성을 높이고 관심사의 분리를 통해 유지보수를 간소화하는데 도움을 줍니다.
- 주요한 AOP 프레임워크로는 Java 에서는 Spring AOP, Python 에서는 AspectLib, .NET에서는 PostSharp
---

### 장점
- 모듈성 향상
  - AOP는 공통 관심사를 모듈화하여 코드에서 분리함으로써 모듈성을 향상
  - 이로 인해 코드의 가독성과 이해도가 증가하며, 유지보수성이 향상
- 중복 제거
  - 공통 관심사를 여러 모듈에 중복해서 저장X
  - 로깅이나 보안과 같은 부분을 여러 곳에 복사하지 않고도 중앙에서 관리할 수 있음
- 핵심 로직 간결화
  - AOP를 사용하면 핵심 비즈니스 로직과 공통 관심사를 분리할 수 있기 때문에 핵심 로직이 더 간결
- 유연성
  - AOP는 코드 수정 없이도 공통 관심사를 추가하거나 변경할 수 있는 유연성을 제공
- 효율적인 개발
  - AOP를 사용하면 공통 기능을 모듈화하고 재사용할 수 있으므로 개발 시간과 노력을 절약

### 단점
- 복잡성
  - AOP를 이해하고 사용하는 것이 일반적인 객체지향 프로그래밍보다 복잡할 수 있음
  - 특히 처음 사용하는 개발자들은 개념을 익히는 데 시간이 걸릴 수 있음
- 디버깅과 추적의 어려움
  - AOP를 사용하면 코드가 여러 곳에 흩어지게 되므로 디버깅하거나 특정 동작을 추적하기 어려울 수 있음
- 오버헤드
  - AOP를 구현하려면 추가적인 작업이 필요하며, 이로 인해 약간의 오버헤드가 발생할 수 있음
- 적용 범위의 혼동
  - 어떤 Aspect를 어디에 적용해야 하는지 혼란스러울 수 있음
  - 적절한 시점과 범위를 선택하는 것이 중요
- 기존 코드와의 통합의 어려움
  - 이미 개발된 코드와 AOP를 통합하는 것이 어려울 수 있음
  - 특히 대규모 애플리케이션의 경우 기존 코드와의 호환성을 유지하면서 AOP를 적용하는 것이 복잡할 수 있음
