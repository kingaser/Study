## IoC 제어의 역전
소프트웨어 디자인 패턴 중 하나로, 프로그램의 제어 흐름이 개발자가 작성한 코드가 아니라 외부의 프레임워크나 컨테이너에 의해 결정되는 것을 말합니다. 
이것은 프로그램의 제어 흐름이 전통적인 흐름에서 역전되었다는 의미를 갖고 있습니다.

일반적으로 프로그래밍에서는 개발자가 코드를 작성하고, 그 코드가 실행되면서 제어 흐름이 개발자가 작성한 코드에 따라 진행됩니다.
그러나 IoC에서는 프레임워크나 컨테이너가 애플리케이션의 제어 흐름을 관리하며, 개발자가 특정 기능을 구현하고 그 기능을
프레임워크에 등록한 후, 프레임워크가 필요한 시점에 해당 기능을 호출 합니다.

IoC는 주로 다음과 같은 방식으로 구현됩니다.
- 의존성 주입(Dependency Injection) : 객체가 필요로 하는 의존성을 직접 생성하지 않고, 외부에서 주입받는 방식입니다..
이를 통해 개발자는 해당 객체의 생성에 직접적으로 관여하지 않고 외부에서 관리됩니다.
- 컨테이너 사용 : 프레임워크나 컨테이너가 객체의 라이프사이클을 관리하고, 필요한 객체를 생성하고 소멸시키는 역할을 합니다.
개발자는 컨테이너에 필요한 객체를 등록하고, 컨테이너에게 필요한 객체를 요청함으로써 객체의 생성과 관리를 외부로 넘깁니다.

IoC는 소프트웨어의 확장성과 유지보수성을 향상시키는데 기여할 수 있습니다. 외부에서 제어 흐름을 관리하면서 모듈 간의
결합도를 낮출 수 있으며, 유연하고 재사용 가능한 코드를 작성할 수 있습니다.

### IoC 사용 이유
- 개발자가 객체의 생명주기에 대한 세세한 걸 신경쓰지 않고 비즈니스 로직에만 신경 쓸 수 있게 해주기 위함
- IoC로 인해 개발자는 비즈니스 로직에만 집중할 수 있고, 나머지는 프레임워크에 포함된 컨테이너(IoC 컨테이너)가 처리함

### IoC 구현방법
1. Factory Pattern
  - 객체 생성을 전담하는 팩토리 클래스를 두어 객체를 생성하는 방식
  - 팩토리 클래스를 사용하여 객체를 생성하면, 객체 생성에 대한 책임이 팩토리 클래스로 이전되므로 IoC가 구현됨
2. Template Method Pattern
  - 객체 생성 과정을 추상화하여 하위 클래스에서 구체적인 구현을 담당하는 방식
  - 하위 클래스에서 구현하는 부분에 대한 제어의 역전이 이루어지므로 IoC가 구현됨
3. Service Locator Pattern
  - 객체 생성 및 관리를 위한 서비스 위치자 패턴
  - 서비스 로케이터 클래스는 객체 생성 및 관리에 대한 책임을 가지며, 클라이언트는 서비스 로케이터를 통해 필요한 객체를 가져오게 됨
  - 따라서 서비스 로케이터 클래스가 객체의 생성과 관리를 담당하므로 제어의 역전이 이루어져 IoC가 구현됨
4. Dependency Injection(DI)
  - 객체 생성 및 관리에 대한 책임을 IoC 컨테이너가 가지며, 필요한 객체를 직접 생성하거나 외부에서 주입받는 방식
  - DI는 생성자 주입, 속성 주입, 메서드 주입 등 다양한 방식으로 이루어질 수 있음

### IoC 장단점
장점
- 코드의 유연성과 재사용성이 증가
  - IoC 컨테이너를 사용하면 의존성을 관리하기 쉬워져 코드 변경이 쉬워짐
    
- 테스트의 용이성 증가
  - 의존성 주입을 통해 테스트용 객체를 쉽게 만들 수 있으므로 테스트 코드 작성에 있어서도 도움이 됨

- 낮은 결합도로 인한 유지보수의 용이성
  - 의존성을 관리하는 작업이 자동화되어 객체 간의 결합도가 낮아져 유지보수가 용이해짐

- 객체간의 의존성 관리를 통해 개발 시간 단축

단점
- 의존성 주입이 많아질수록 코드의 가독성이 떨어지거나 코드의 복잡성이 증가할 수 있음
- IoC 컨테이너가 복잡해질수록 초기 설정과 성능 이슈가 발생할 수 있음
- IoC 컨테이너를 사용하면 일부 개발자는 어떤 객체가 어떻게 생성되는지에 대한 이해를 잃을 수 있음

### 스프링 컨테이너(IoC 컨테이너)
1. BeanFactory
  - 자바 객체(Bean) 인스턴스를 생성, 설정, 관리하는 실질적인 컨테이너
  - getBean() 메서드를 통해 빈을 인스턴스화 할 수 있음
  - BeanFactory 컨테이너는 구동될 때 Bean 객체를 생성하는 것이 아니라, 클라이언트의 요청이 있을 때 Bean 객체를 생성

2. ApplicationContext
  - BeanFactory를 상속받은 BeanFactory의 확장 버전
  - BeanFactory를 상속받은 Interface이며, ApplicationContext 컨테이너는 구동되는 시점에 등록된 Bean 객체들을 스캔하여 객체화 함
  - 부가 기능과 빈을 지연 없이 얻을 수 있다는 장점으로 ApplicationContext를 실제 개발에서 주로 사용

스프링 컨테이너가 모든 객체의 생명주기를 관리해주는 것은 아닙니다. 보통은 Controller, Service 등의 역할을 담당하는 특정 객체들만 관리합니다.
이처럼 스프링 컨테이너가 관리하는 자바 객체를 Bean이라 합니다.

## DI 의존성 주입
DI는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고
런타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해줍니다.

- 의존성 : 한 객체가 다른 객체를 사용할 때 의존성이 있다고 말함.
ex) Store 객체가 Pencil 객체를 사용하고 있는 경우 Store객체가 Pencil객체에 의존성이 있다고 표현
![image](https://github.com/kingaser/Study/assets/104209781/b71933cb-7602-4b5e-989d-45ea9762fb08)

### DI가 필요한 이유
1. 두 클래스가 강하게 결합되어 있음
  Store 클래스가 Pencil 클래스와 강하게 결합되어 있다면 Food와 같은 다른 상품을 판매하고자 할때 Store 클래스의 생성자에 변경이 필요함
  즉, 유연성이 떨어짐. 각각의 사른 상품들을 판매하기 위해 생성자만 다르고 나머지는 중복되는 Store 클래스들이 파생되는 것은 좋이 못함.
  이에 대한 해결책으로 상속을 떠올릴 수 있지만, 상속은 제약이 많고 확장성이 떨어지므로 피하는 것이 좋음

2. 객체들 간의 관계가 아니라 클래스 간의 관계가 맺어짐
  Store와 Pencil은 객체들 간의 관계가 아니라 클래스들 간의 관계가 맺어져 있다는 문제가 있음
  올바른 객체지향적 설계라면 객체들 간에 관계가 맺어져야 함. 객체들 간에 관계가 맺어졌다면 다른 객체의 구체 클래스를 전혀 알지 못하더라도
  인터페이스의 타입으로 사용할 수 있음

관심의 분리가 필요함
---
한 객체가 어떤 객체에 의존할 것인지는 별도의 관심사입니다. 의존성 주입을 도와주는 DI컨테이너로써, 강하게 결합된 클래스들을 분리하고, 애플리케이션
실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해줍니다. 이러한 방법은 상속보다 훨씬 유연합니다. 단, 한 객체가
다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 합니다.
- 두 객체 간의 관계라는 관심사의 분리
- 두 객체 간의 결합도를 낮춤
- 객체의 유연성을 높임
- 테스트 작성을 용이하게 함

### 의존성 주입의 종류
- 생성자 주입(Constructor Injection) : 의존성을 객체 생성 시 생성자를 통해 주입하는 방식입니다. 이는 주로 객체의 필수적인 의존성을 주입하는데 사용합니다.
- 메서드 주입(Method Injection) : 의존성을 주입받을 메서드를 통해 주입하는 방식입니다. 생성자의 다른 메서드를 통해 의존성을 주입할 수 있습니다.
- 속성 주입(Property Injection 또는 Setter Injection) : 의존성을 주입받을 프로퍼티(멤버 변수) 를 통해 주입하는 방식입니다. 주로 선택적인 의존성에 사용합니다.
- DI컨테이너(Container) : DI를 구현하고 관리하는데 사용되는 프레임워크나 라이브러리를 의미합니다. DI컨테이너는 객체의 생명주기와 의존성을 추적하고, 필요한 시점에 의존성을 주입합니다.

의존성 주입을 통해 코드의 결합도를 낮추고 테스트 가능한 코드를 작성할 수 있으며, DI컨테이너를 사용하면 객체의 생명주기와 의존성을 효과적으로 관리할 수 있음
