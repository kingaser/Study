## 영속성 컨텍스트
### 엔티티의 생명 주기
- 엔티티를 영구 저장하는 환경입니다.
- 눈에 보이지 않는 논리적인 개념입니다.
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근합니다.
- 비영속 (ner/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태입니다.
- 영속(managed) : 영속성 컨텍스트에 관리되는 상태입니다.
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 부리된 상태입니다.
- 삭제(removed) : 삭제된 상태입니다.
- DB에 저장되는 시점은 persist시점이 아닌 transaction commit 시점입니다.

### 영속성 컨텍스트의 이점
영속성 컨텍스트의 이점으로는
- 1차 캐시
- 동일성(identity)보장
- 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

### 엔티티 조회, 1차 캐시
- 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공합니다.

### 엔티티 등록, 트랜잭션을 지원하는 쓰기 지연
- 1차 캐시에 persist된 객체를 모아놨다가 한번에 DB에 등록할 수 있습니다.

### 엔티티 수정, 변경 감지(Dirty Checking)
- persist없이 수정 가능합니다. 오히려 persist를 사용하면 안됩니다.

### 준영속 상태
- 영속성 컨텍스트가 더는 관리하지 않는 엔티티의 상태를 뜻합니다.
- 한번 영속상태가 되었다가 영속상태를 벗어난 상태입니다.
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태입니다.
- 영속성 컨텍스트가 제공하는 기능을 사용하지 못합니다.
- em.detach(entity) : 특정 엔티티만 준역속 상태로 변환합니다. 1차 캐시에서 빠진다라고 생각하면 이해하기 쉽게 도움이 됩니다.
- em.clear() : 영속성 컨텍스트를 완전히 초기화합니다.
- em.close() : 영속성 컨텍스트를 종료합니다.

### 플러시
- 영속성 컨텍스트의 변경내용을 DB에 반영합니다.
- 영속성 컨텍스트 내용과 DB를 맞추는 과정으로 commit 시 자동으로 일어납니다. 플러시를 한다고 해서 commit이 되는 것은 아닙니다.
- 플러시를 하게되면
  - 수정된 엔티티가 있으면 UPDATE 쿼리를 쓰기 지연 SQl 저장소에 쌓아둡니다.
  - 쌓아둔 등록, 수정, 삭제 쿼리(쓰기 지연 SQL 쿼리)가 DB에 전송됩니다.
  - 플러시를 했다고 영속성 컨텍스트는 비워지지 않습니다. 영속성 컨텍스트를 비우고 싶다면 em.clear() 메서드를 호출해야 합니다.
 
### 플러시가 일어나는 경우
- 플러시가 일어나는 경우로는 직접 em.flush()를 호출하거나, 자동호출이 있습니다.
- 직접 호출하는 경우에는 사용자가 메서드를 통해 영속성 컨텍스트를 플러시합니다.
- 자동 호출 시에는 트랜잭션 커밋이 일어나면 플러시를 호출할 수 있고, JPQL 쿼리 실행 전에 플러시를 호출합니다.

